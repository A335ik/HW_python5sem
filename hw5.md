# Уроки 4-5 - полиморфизм, наследование, декораторы и итераторы
## Контрольные вопросы:
- В чем основная идея __полиморфизма__? Как он реализуется в Python.
<br> Идея __полиморфизма__ заключается в использовании единственной сущности(метода, оператора или объекта) для представления различных типов в различных сценариях использования.
<br> Пример: оператор + работает по разному для строк и целочисленного типа данных.
- Зачем переопределять метод `__radd__()` наравне с 
`__add__()`?
<br><br>Метод __add__() — это метод, используемый для определения поведения оператора сложения (+), когда он применяется к объектам класса. Когда складываются два объекта класса, у которого есть метод __add__(), Python неявно вызывает этот метод.
<br>Чтобы реализовать метод __add__(), необходимо определить его в своем классе, принимая один параметр помимо self: другой объект, который будет добавлен. Метод должен возвращать новый объект, который представляет сумму двух объектов.

<br>Метод __radd__() дополняет __add__(), определяя поведение оператора сложения, когда левый операнд не имеет метода __add__(), или когда его метод __add__() не знает, как обработать правый операнд.
<br>Как правило, __radd__() реализуется так же, как __add__(). Это гарантирует, что операции сложения, включающие экземпляры класса, симметричны, то есть a + b даст тот же результат, что и b + a, когда один из них является экземпляром вашего класса.
- Как можно описать взаимоотношения 
__родительского__ и __дочернего__ классов?
- Для чего используется ключевое 
слово `super()`?
- Какую роль играет порядок классов __предков__
при __множественном наследовании__?
- Зачем нужна __обработка исключений__? В каких 
случаях ее использование некорректно?
- Зачем в блоке `try` использовать раздел
`finally`?
- Что нужно сделать, чтобы реализовать 
свое собственное __исключение__?
- Чем итератор отличается от генератора?
- В чем минусы декорирования функций?


## Задания:
1) Доработайте класс комплексного числа из прошлого 
занятия: переопределите математические 
операторы (__+, -, /, *, ==__), так, чтобы они
работали с другими комплексными и со стандартными
числами. Добейтесь правильной работы с комплексным 
числом функций `print()`, `abs()`, а также
реализуйте `getter` и `setter` 
с использованием декоратора `@property`. Добавьте 
выбросы исключений при некорректном использовании 
вашего числа, например: выбросом `ValueError` при вводе 
некорректных значений в `setter` класса, выбросом своего исключения в 
случае попытки перевода в экспоненциальную 
форму, когда это невозможно. Поверх напишите программу 
калькулятор, принимающую у пользователя два комплексных
числа и проводящую с ними арифметические операции на
выбор пользователя. Калькулятор должен уметь ловить и 
обрабатывать исключения, не роняя программу,
а объясняя пользователю, что пошло не так.
2) Реализуйте класс связного списка `LinkedList`. 
(Вам потребуется реализовать вспомогательный класс `Node`,
содержащий в себе ссылки на соседей, и свое значение. Тогда
сам список содержит в себе лишь ссылку на первую вершину,
и вспомогательные данные вроде текущей длины). Список 
должен поддерживать обращение по индексам, красиво печататься,
выдавать длину через `len()` и иметь работающие методы
`.pop()`, `.append()`. Также список должен поддерживать
итерацию по нему. *Можете также добавить `.insert()` и 
`.pop()` по индексу.
3) Реализовать структуру наследования классов 
геометрических фигур *shape*. Каждый 
класс должен обладать методами `.area()`_ и 
`.perimeter()` для вычисления площади и 
периметра соответственно, а также метод `__str__()`. Среди обязательных для 
реализации структур: круг, треугольник, 
прямоугольник, квадрат, ромб. Для простоты часть фигур
можно конструировать из точек, 
передающихся в порядке обхода фигуры по 
часовой стрелке.
